*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.20" SourceFile="listmanager.vcx" CPID="1252" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS listmanager AS sfcustom OF "sfctrls.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: getvaluesfortype		&& Gets the values for the specified type
		*m: openlisttable		&& Opens the list table if necessary
		*p: calias		&& The alias for the list table
		*p: clanguage		&& The language to use for localization
		*p: ctable		&& The name of the list table
		*p: cversion		&& The version number
	*</DefinedPropArrayMethod>

	*<PropValue>
		calias = 
		clanguage = English
		ctable = list.dbf
		cversion = 1.0.09002
		Name = "listmanager"
		_memberdata = <VFPData>
			<memberdata name="getvaluesfortype" display="GetValuesForType"/>
			<memberdata name="openlisttable" display="OpenListTable"/>
			<memberdata name="ctable" display="cTable"/>
			<memberdata name="calias" display="cAlias"/>
			<memberdata name="clanguage" display="cLanguage"/>
			<memberdata name="cversion" display="cVersion"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE about
		*==============================================================================
		* Class:						ListManager
		* Based On:						SFCustom
		* Purpose:						List manager object
		* Author:						Doug Hennig
		* Last revision:				04/01/2023
		* Include file:					none
		*
		* Changes in "Based On" class properties:
		*	none
		*
		* Changes in "Based On" class methods:
		*	Init:						set the alias for the list table
		*
		* Custom public properties added:
		*	cAlias:						the alias for the list table
		*	cLanguage:					the language to use for localization (defaults
		*								to English)
		*	cTable:						the name of the list table
		*
		* Custom protected properties added:
		*	none
		*
		* Custom public methods added:
		*	GetValuesForType:			gets the value for the specified type
		*
		* Custom protected methods added:
		*	OpenListTable:				opens the list table if necessary
		*==============================================================================
		
	ENDPROC

	PROCEDURE getvaluesfortype		&& Gets the values for the specified type
		*==============================================================================
		* Method:			GetValuesForType
		* Status:			Public
		* Purpose:			Gets the values for the specified type
		* Author:			Doug Hennig
		* Last Revision:	04/01/2023
		* Parameters:		tuItems        - the array to store the values into or the
		*						name of a cursor to create
		*					tuListType     - the list type to get values for
		*					tnParentID     - the parent to get values for (optional: if
		*						it isn't specified, parent is ignored)
		*					tlIncludeBlank - .T. to include a blank row
		*					tnDataSession  - the data session to create the cursor in
		*						(optional)
		* Returns:			the number of items
		* Environment in:	none
		* Environment out:	the list table is open
		*					the specified array or cursor contains 4 columns: Value,
		*						ID, ParentID, and Abbrev
		*==============================================================================
		
		lparameters tuItems, ;
			tuListType, ;
			tnParentID, ;
			tlIncludeBlank, ;
			tnDataSession
		external array tuItems
		local lcFilter, ;
			llArray, ;
			lnSelect, ;
			llCursor, ;
			lcResult, ;
			lnDataSession, ;
			llDataSession, ;
			lnItems, ;
			lnI
		lcFilter = iif(empty(tnParentID), '', 'and ParentID = tnParentID')
		llArray  = type('tuItems', 1) = 'A'
		if llArray
			lcResult = 'into array tuItems'
		else
			lcResult      = 'into cursor (tuItems) readwrite'
			lnDataSession = set('DATASESSION')
			llDataSession = vartype(tnDataSession) = 'N' and lnDataSession <> tnDataSession
			if llDataSession
				set datasession to tnDataSession
			endif llDataSession
			lnSelect = select()
		endif llArray
		This.OpenListTable()
		lcCollate = set('COLLATE')
		try
			set collate to 'GENERAL'
				&& use General so sorting is case-insensitive
		catch
		endtry
		select distinct Value, ID, ParentID, Abbrev ;
			from (This.cAlias) ;
			where Type = tuListType ;
				and not deleted() ;
				&lcFilter ;
			order by 1 ;
			&lcResult
		try
			set collate to (lcCollate)
		catch
		endtry
		lnItems = _tally
		do case
			case llArray
				for lnI = 1 to lnItems
					tuItems[lnI, 1] = trim(tuItems[lnI, 1])
				next lnI
				if tlIncludeBlank
					dimension tuItems[lnItems + 1, 3]
					tuItems[lnItems + 1, 1] = ''
					tuItems[lnItems + 1, 2] = 0
					tuItems[lnItems + 1, 3] = 0
				endif tlIncludeBlank
			case tlIncludeBlank
				append blank
		endcase
		if llDataSession
			set datasession to lnDataSession
			lnSelect = select()
		endif llDataSession
		return lnItems
		
	ENDPROC

	PROCEDURE Init
		* Set the alias for the list table to a unique value.
		
		This.cAlias = sys(2015)
		
	ENDPROC

	PROTECTED PROCEDURE openlisttable		&& Opens the list table if necessary
		if not used(This.cAlias)
		
		* Create the list table if necessary.
		
			if not file(This.cTable)
				create table (This.cTable) free ;
					(ID I autoinc, ;
					Type I, ;
					Value C(254), ;
					ParentID I)
				index on ID tag ID
				use
			endif not file(This.cTable)
		
		* Open the list table if necessary.
		
			use (This.cTable) alias (This.cAlias) again shared in 0
		endif not used(This.cAlias)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS listmanagercombobox AS sfcontainer OF "sfctrls.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cboCombo" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdEdit" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: adjustpositions		&& Adjust object positions
		*m: allowedit_assign
		*m: anychange		&& Fired when a value is selected
		*m: id_access
		*m: parentid_assign
		*m: requery		&& Loads the combobox with the items for the specified type and parent
		*m: value_access
		*m: value_assign
		*p: allowblank		&& .T. to allow a blank value in the list
		*p: allowedit		&& .T. to show the edit button
		*p: allowtyping		&& .T. to allow the user to type a non-list value
		*p: boundtoid		&& .T. if we're bound to the ID of the list item or .F. if we're bound to the value
		*p: controlsource		&& Specifies the source of data to which an object is bound
		*p: fontname		&& The font name
		*p: fontsize		&& The font size
		*p: id		&& The ID of the selected item
		*p: listtype		&& The type this control is for
		*p: parentid		&& The parent this control is for
		*p: typedescription		&& The description for the list type
		*p: value		&& The value of the control
	*</DefinedPropArrayMethod>

	*<PropValue>
		allowblank = .F.
		allowedit = .T.
		allowtyping = .F.
		boundtoid = .T.
		builder = (addbs(justpath(This.ClassLibrary)) + 'listmanagerbuilder.prg')
		controlsource = 
		fontname = Segoe UI
		fontsize = 9
		Height = 24
		id = 0
		listtype = 
		Name = "listmanagercombobox"
		parentid = 0
		typedescription = 
		value = 
		Width = 124
		_memberdata = <VFPData>
			<memberdata name="requery" display="Requery"/>
			<memberdata name="controlsource" display="ControlSource"/>
			<memberdata name="value" display="Value"/>
			<memberdata name="value_access" display="Value_Access"/>
			<memberdata name="value_assign" display="Value_Assign"/>
			<memberdata name="anychange" display="AnyChange"/>
			<memberdata name="adjustpositions" display="AdjustPositions"/>
			<memberdata name="typedescription" display="TypeDescription"/>
			<memberdata name="allowedit" display="AllowEdit"/>
			<memberdata name="allowedit_assign" display="AllowEdit_Assign"/>
			<memberdata name="boundtoid" display="BoundToID"/>
			<memberdata name="id" display="ID"/>
			<memberdata name="id_access" display="ID_Access"/>
			<memberdata name="parentid" display="ParentID"/>
			<memberdata name="parentid_assign" display="ParentID_Assign"/>
			<memberdata name="listtype" display="ListType"/>
			<memberdata name="allowtyping" display="AllowTyping"/>
			<memberdata name="allowblank" display="AllowBlank"/>
			<memberdata name="fontname" display="FontName"/>
			<memberdata name="fontsize" display="FontSize"/>
		</VFPData>
	*</PropValue>

	ADD OBJECT 'cboCombo' AS sfcombobox WITH ;
		Anchor = 10, ;
		Left = 0, ;
		lupdatecontrolsource = .T., ;
		Name = "cboCombo", ;
		Top = 0
		*< END OBJECT: ClassLib="sfctrls.vcx" BaseClass="combobox" />

	ADD OBJECT 'cmdEdit' AS sfcommandbutton WITH ;
		Anchor = 8, ;
		Caption = "", ;
		Height = 24, ;
		Left = 100, ;
		Name = "cmdEdit", ;
		Picture = editlisttable.bmp, ;
		ToolTipText = "Add, edit, or remove items from the list of values", ;
		Top = 0, ;
		Width = 24
		*< END OBJECT: ClassLib="sfctrls.vcx" BaseClass="commandbutton" />
	
	PROCEDURE about
		*==============================================================================
		* Class:						ListManagerComboBox
		* Based On:						SFContainer
		* Purpose:						Allows selection of a list item
		* Author:						Doug Hennig
		* Last revision:				04/01/2023
		* Include file:					None
		*
		* Changes in "Based On" class properties:
		*	Builder:					listmanagerbuilder.prg in same folder as VCX
		*	Height:						24
		*	Width:						124
		*
		* Changes in "Based On" class methods:
		*	Init:						set up the control
		*
		* Custom public properties added:
		*	AllowBlank:					.T. to include a blank value in the list
		*	AllowEdit:					.T. to show the edit button (Assign method)
		*	AllowTyping:				.T. to allow the user to type a non-list value
		*	BoundToID:					.T. if we're bound to the ID of the list item
		*								or .F. if we're bound to the value
		*	ControlSource:				specifies the source of data to which an object
		*								is bound
		*	FontName:					the font name
		*	FontSize:					the font size
		*	ID:							the ID of the selected item (Access method)
		*	ListType:					the type this control is for
		*	ParentID:					the parent this control is for (Assign method)
		*	TypeDescription:			the description for the list type
		*	Value:						the value of the control (Access and Assign
		*								methods)
		*
		* Custom protected properties added:
		*	none
		*
		* Custom public methods added:
		*	AnyChange:					fired when a value is selected
		*	Requery:					loads the combobox with the items for the
		*								specified type and parent
		*
		* Custom protected methods added:
		*	AdjustPositions:			adjust object positions
		*==============================================================================
		
	ENDPROC

	PROTECTED PROCEDURE adjustpositions		&& Adjust object positions
		with This
			if .AllowEdit
				.cmdEdit.Visible      = .T.
				.cmdEdit.lSaveAnchor  = .T.
				.cmdEdit.Left         = .Width - .cmdEdit.Width
				.cmdEdit.lSaveAnchor  = .F.
				.cboCombo.lSaveAnchor = .T.
				.cboCombo.Width       = .Width - .cmdEdit.Width
				.cboCombo.lSaveAnchor = .F.
			else
				.cmdEdit.Visible      = .F.
				.cboCombo.lSaveAnchor = .T.
				.cboCombo.Width       = .Width
				.cboCombo.lSaveAnchor = .F.
			endif .AllowEdit
		endwith
		
	ENDPROC

	PROCEDURE allowedit_assign
		lparameters tlAllowEdit
		This.AllowEdit = tlAllowEdit
		This.AdjustPositions()
		
	ENDPROC

	PROCEDURE anychange		&& Fired when a value is selected
		* Abstract method
		
	ENDPROC

	PROCEDURE id_access
		if alen(This.cboCombo.aItems) > 1 and This.cboCombo.ListIndex > 0 and ;
			This.cboCombo.ListIndex <= alen(This.cboCombo.aItems, 1)
			lnReturn = This.cboCombo.aItems[This.cboCombo.ListIndex, 2]
		else
			lnReturn = 0
		endif alen(This.cboCombo.aItems) > 1 ...
		return lnReturn
		
	ENDPROC

	PROCEDURE Init
		* Set up the control.
		
		dodefault()
		with This
			if .BoundToID
				.cboCombo.BoundColumn = 2
				.cboCombo.BoundTo     = .T.
			else
				.cboCombo.BoundColumn = 1
				This.cboCombo.BoundTo     = .F.
			endif .BoundToID
			.cboCombo.Style         = iif(.AllowTyping and not .BoundToID, 0, 2)
			.cboCombo.FontName      = .FontName
			.cboCombo.FontSize      = .FontSize
			.cboCombo.ToolTipText   = .ToolTipText
			.cboCombo.ControlSource = .ControlSource
			.AdjustPositions()
			.Requery()
		endwith
		
	ENDPROC

	PROCEDURE parentid_assign
		lparameters tnID
		This.ParentID = tnID
		This.Requery()
		
	ENDPROC

	PROCEDURE requery		&& Loads the combobox with the items for the specified type and parent
		local lnID, ;
			laItems[1], ;
			lnItems, ;
			lnIndex
		if not empty(This.ListType)
		
		* Create a list manager object if necessary.
		
			if type('_vfp.oListManager') <> 'O' or isnull(_vfp.oListManager)
				addproperty(_vfp, 'oListManager', newobject('ListManager', This.ClassLibrary))
			endif type('_vfp.oListManager') <> 'O' ...
		
		* Get the values for the specified type and parent.
		
			lnID    = This.ID
			lnItems = _vfp.oListManager.GetValuesForType(@laItems, This.ListType, This.ParentID, ;
				This.AllowBlank)
			dimension This.cboCombo.aItems[1]
			acopy(laItems, This.cboCombo.aItems)
			This.cboCombo.Requery()
		
		* Set ListIndex to the position for the previous value if possible.
		
			if lnItems > 0
				lnIndex = ascan(This.cboCombo.aItems, lnID, -1, -1, 2, 8)
			else
				lnIndex = 0
			endif lnItems > 0
			if This.cboCombo.ListIndex <> lnIndex
				This.cboCombo.ListIndex = lnIndex
			endif This.cboCombo.ListIndex <> lnIndex
		endif not empty(This.ListType)
		
	ENDPROC

	PROCEDURE value_access
		return This.cboCombo.Value
		
	ENDPROC

	PROCEDURE value_assign
		lparameters tcValue
		This.cboCombo.Value = tcValue
		
	ENDPROC

	PROCEDURE cboCombo.anychange
		This.Parent.AnyChange()
		
	ENDPROC

	PROCEDURE cboCombo.validation
		* If the user typed a value that's not in the list, add it to the array.
		
		local lnItems, ;
			lnCols
		if This.Parent.AllowTyping and not This.DisplayValue == This.Value and ;
			ascan(This.aItems, This.DisplayValue, -1, -1, 1, 15) = 0
			lnItems = alen(This.aItems, 1)
			lnCols  = alen(This.aItems, 2)
			dimension This.aItems[lnItems + 1, lnCols]
			This.aItems[lnItems + 1, 1] = This.DisplayValue
			This.aItems[lnItems + 1, 2] = 0
			This.aItems[lnItems + 1, 3] = 0
			asort(This.aItems)
			This.Requery()
			This.Value = This.DisplayValue
		endif This.Parent.AllowTyping ...
		
	ENDPROC

	PROCEDURE cmdEdit.Click
		local loForm
		loForm = newobject('ListManagerEditForm', This.Parent.ClassLibrary, '', ;
			This.Parent.TypeDescription, This.Parent.ListType, This.Parent.ParentID)
		loForm.Show()
		This.Parent.Requery()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS listmanagercombotree AS sfcombotree OF "sfcombotree.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cmdEdit" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: adjustpositions		&& Adjust object positions
		*m: allowedit_assign
		*m: requery		&& Loads the tree with the items for the specified type and parent
		*m: value_access
		*m: value_assign
		*p: allowedit		&& .T. to show the edit button
		*p: controlsource		&& Specifies the source of data to which an object is bound
		*p: listtype		&& The list type this control is for
		*p: typedescription		&& The description for the list type
		*p: useabbreviation		&& .T. to use the abbreviation for the value
		*p: value		&& The value of the control
	*</DefinedPropArrayMethod>

	*<PropValue>
		allowedit = .T.
		builder = (addbs(justpath(This.ClassLibrary)) + 'listmanagerbuilder.prg')
		controlsource = 
		listtype = 
		Name = "listmanagercombotree"
		typedescription = 
		useabbreviation = .F.
		value = 
		Width = 194
		_memberdata = <VFPData>
			<memberdata name="controlsource" display="ControlSource"/>
			<memberdata name="requery" display="Requery"/>
			<memberdata name="adjustpositions" display="AdjustPositions"/>
			<memberdata name="listtype" display="ListType"/>
			<memberdata name="allowedit" display="AllowEdit"/>
			<memberdata name="typedescription" display="TypeDescription"/>
			<memberdata name="allowedit_assign" display="AllowEdit_Assign"/>
			<memberdata name="value" display="Value"/>
			<memberdata name="value_access" display="Value_Access"/>
			<memberdata name="value_assign" display="Value_Assign"/>
			<memberdata name="useabbreviation" display="UseAbbreviation"/>
		</VFPData>
		cboCombo.lupdatecontrolsource = .T.
		cboCombo.Name = "cboCombo"
		oTree.Height = 174
		oTree.Left = 5
		oTree.Name = "oTree"
		oTree.Top = 29
		oTree.Width = 166
		shpTreeView.Name = "shpTreeView"
	*</PropValue>

	ADD OBJECT 'cmdEdit' AS sfcommandbutton WITH ;
		Anchor = 8, ;
		Caption = "", ;
		Height = 24, ;
		Left = 168, ;
		Name = "cmdEdit", ;
		Picture = editlisttable.bmp, ;
		ToolTipText = "Add, edit, or remove items from the list of values", ;
		Top = 0, ;
		Width = 24
		*< END OBJECT: ClassLib="sfctrls.vcx" BaseClass="commandbutton" />
	
	PROCEDURE about
		*==============================================================================
		* Class:						ListManagerComboTree
		* Based On:						SFComboTree
		* Purpose:						Allows selection of multiple list items
		* Author:						Doug Hennig
		* Last revision:				04/01/2023
		* Include file:					none
		*
		* Changes in "Based On" class properties:
		*	Builder:					listmanagerbuilder.prg in same folder as VCX
		*
		* Changes in "Based On" class methods:
		*	CloseControl:				put the checked items into the combobox
		*	LoadTree:					load the tree with items for the specified type
		*	OpenControl:				make sure all selected items are checked
		*
		* Custom public properties added:
		*	AllowEdit:					.T. to show the edit button (Assign method)
		*	ControlSource:				specifies what the control is bound to
		*	ListType:					the list type this control is for
		*	TypeDescription:			the description for the list type
		*	UseAbbreviation:			.T. to use the abbreviation for the value
		*	Value:						the value of the control (Access and Assign
		*								methods)
		*
		* Custom protected properties added:
		*	none
		*
		* Custom public methods added:
		*	Requery:					loads the tree with the items for the
		*								specified type and parent
		*
		* Custom protected methods added:
		*	AdjustPositions:			adjust object positions
		*==============================================================================
		
	ENDPROC

	PROTECTED PROCEDURE adjustpositions		&& Adjust object positions
		with This
			if .AllowEdit
				.cmdEdit.Visible      = .T.
				.cmdEdit.lSaveAnchor  = .T.
				.cmdEdit.Left         = .Width - .cmdEdit.Width
				.cmdEdit.lSaveAnchor  = .F.
				.cboCombo.lSaveAnchor = .T.
				.cboCombo.Width       = .Width - .cmdEdit.Width
				.cboCombo.lSaveAnchor = .F.
			else
				.cmdEdit.Visible      = .F.
				.cboCombo.lSaveAnchor = .T.
				.cboCombo.Width       = .Width
				.cboCombo.lSaveAnchor = .F.
			endif .AllowEdit
		endwith
		
	ENDPROC

	PROCEDURE allowedit_assign
		lparameters tlAllowEdit
		This.AllowEdit = tlAllowEdit
		This.AdjustPositions()
		
	ENDPROC

	PROCEDURE closecontrol
		lparameters tlKeepFocus, ;
			tlSelected
		local lcItems, ;
			loNode, ;
			lcText
		dodefault(tlKeepFocus, tlSelected, .T.)
		with This
		
		* Get the selected items.
		
			if tlSelected
				lcItems = ''
				for each loNode in .oTree.Nodes
					if loNode.Checked
						lcText  = iif(This.UseAbbreviation, trim(left(loNode.Text, at('-', loNode.Text) - 1)), ;
							loNode.Text)
						lcItems = lcItems + iif(empty(lcItems), '', ',') + lcText
					endif loNode.Checked
				next loNode
				store lcItems to .cboCombo.DisplayValue, .cboCombo.Value
		
		* Call ItemSelected to do any custom behavior.
		
				.ItemSelected()
			endif tlSelected
		endwith
		
	ENDPROC

	PROCEDURE Init
		with This
		
		* Set up the TreeView the way we want.
		
			.oTree.Checkboxes = .T.
			.oTree.Style      = 0
		
		* Do the usual behavior.
		
			dodefault()
		
		* Set up the combobox.
		
			.AdjustPositions()
			.cboCombo.ToolTipText   = .ToolTipText
			.cboCombo.ControlSource = .ControlSource
		endwith
		
	ENDPROC

	PROCEDURE loadtree
		* Load the tree with the items for the specified type.
		
		local laItems[1], ;
			lnItems, ;
			llNumericKey, ;
			lnI, ;
			lcItem, ;
			loNode
		if not empty(This.ListType)
		
		* Create a list manager object if necessary.
		
			if type('_vfp.oListManager') <> 'O' or isnull(_vfp.oListManager)
				addproperty(_vfp, 'oListManager', newobject('ListManager', This.ClassLibrary))
			endif type('_vfp.oListManager') <> 'O' ...
		
		* Get the values for the specified type and parent.
		
			lnItems      = _vfp.oListManager.GetValuesForType(@laItems, This.ListType)
			llNumericKey = vartype(laItems[1, 2]) = 'N'
			This.oTree.Nodes.Clear()
			for lnI = 1 to lnItems
				lcItem = iif(This.UseAbbreviation, trim(laItems[lnI, 4]) + ' - ', '') + ;
					trim(laItems[lnI, 1])
				loNode = This.oTree.Nodes.Add(, 1, ;
					iif(llNumericKey, 'N' + transform(laItems[lnI, 2]), ;
					laItems[lnI, 2]), lcItem)
			next lnI
		endif not empty(This.ListType)
		
	ENDPROC

	PROCEDURE opencontrol
		* Make sure all selected items are checked.
		
		local lnI, ;
			loNode, ;
			lcText
		for lnI = 1 to This.oTree.Nodes.Count
			loNode = This.oTree.Nodes[lnI]
			lcText = iif(This.UseAbbreviation, trim(left(loNode.Text, at('-', loNode.Text) - 1)), ;
				loNode.Text)
			loNode.Checked = ',' + lcText + ',' $ ',' + alltrim(.cboCombo.DisplayValue) + ','
		next lnI
		dodefault()
		
	ENDPROC

	PROCEDURE requery		&& Loads the tree with the items for the specified type and parent
		This.LoadTree()
		
	ENDPROC

	PROCEDURE value_access
		return This.cboCombo.Value
		
	ENDPROC

	PROCEDURE value_assign
		lparameters tcValue
		This.cboCombo.Value = tcValue
		
	ENDPROC

	PROCEDURE cmdEdit.Click
		local loForm
		loForm = newobject('ListManagerEditForm', This.Parent.ClassLibrary, '', ;
			This.Parent.TypeDescription, This.Parent.ListType, 0, ;
			This.Parent.UseAbbreviation)
		loForm.Show()
		This.Parent.Requery()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS listmanagereditform AS sfmodaldialog OF "sfctrls.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="grdValues" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdValues.Column1.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdValues.Column1.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdValues.Column2.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdValues.Column2.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdAdd" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdRemove" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*p: listtype		&& The type for the values
		*p: parentid		&& The parent ID for the values
	*</DefinedPropArrayMethod>

	*<PropValue>
		DataSession = 2
		DoCreate = .T.
		Height = 250
		Icon = editlisttable.ico
		listtype = 
		Name = "listmanagereditform"
		parentid = 
		Width = 340
		_memberdata = <VFPData>
			<memberdata name="parentid" display="ParentID"/>
			<memberdata name="listtype" display="ListType"/>
		</VFPData>
	*</PropValue>

	ADD OBJECT 'cmdAdd' AS sfcommandbutton WITH ;
		Anchor = 132, ;
		Caption = "Add", ;
		Left = 85, ;
		Name = "cmdAdd", ;
		Top = 215
		*< END OBJECT: ClassLib="sfctrls.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdRemove' AS sfcommandbutton WITH ;
		Anchor = 36, ;
		Caption = "Remove", ;
		Left = 171, ;
		Name = "cmdRemove", ;
		Top = 215
		*< END OBJECT: ClassLib="sfctrls.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'grdValues' AS sfgrid WITH ;
		ColumnCount = 2, ;
		DeleteMark = .F., ;
		GridLines = 2, ;
		Height = 199, ;
		HighlightRow = .F., ;
		Left = 10, ;
		Name = "grdValues", ;
		RecordMark = .F., ;
		ScrollBars = 2, ;
		Top = 10, ;
		Width = 320, ;
		Column1.FontName = "Segoe UI", ;
		Column1.Name = "Column1", ;
		Column1.Width = 248, ;
		Column2.FontName = "Segoe UI", ;
		Column2.Name = "Column2", ;
		Column2.Width = 50
		*< END OBJECT: ClassLib="sfctrls.vcx" BaseClass="grid" />

	ADD OBJECT 'grdValues.Column1.Header1' AS header WITH ;
		Caption = "Value", ;
		FontName = "Segoe UI", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdValues.Column1.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		FontName = "Segoe UI", ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1"
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'grdValues.Column2.Header1' AS header WITH ;
		Caption = "Abbrev", ;
		FontName = "Segoe UI", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdValues.Column2.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		FontName = "Segoe UI", ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1"
		*< END OBJECT: BaseClass="textbox" />
	
	PROCEDURE about
		*==============================================================================
		* Class:						ListManagerEditForm
		* Based On:						SFModalDialog
		* Purpose:						Form to add, edit, and remove list items
		* Author:						Doug Hennig
		* Last revision:				04/02/2023
		* Include file:					none
		*
		* Changes in "Based On" class properties:
		*	DataSession:				2-Private
		*	Height:						250
		*	Width:						340
		*
		* Changes in "Based On" class methods:
		*	Destroy:					save changes
		*	Init:						set up the controls
		*	KeyPress:					close on Esc
		*
		* Custom public properties added:
		*	ListType:					the type for the values
		*	ParentID:					the parent ID for the values
		*
		* Custom protected properties added:
		*	None
		*
		* Custom public methods added:
		*	None
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE Destroy
		* Save the changes to the list table.
		
		local lcAlias
		lcAlias = _vfp.oListManager.cAlias
		if not used(lcAlias)
			use (_vfp.oListManager.cTable) alias (lcAlias) again shared in 0
		endif not used(lcAlias)
		select curValues
		set deleted off
		scan
			do case
				case not seek(curValues.ID, lcAlias, 'ID')
					insert into (lcAlias) ;
							(Type, Value, Abbrev, ParentID) ;
						values ;
							(This.ListType, curValues.Value, curValues.Abbrev, This.ParentID)
				case deleted('curValues')
					delete in (lcAlias)
				otherwise
					replace Value with curValues.Value, Abbrev with curValues.Abbrev in (lcAlias)
			endcase
		endscan
		set deleted on
		use in curValues
		dodefault()
		
	ENDPROC

	PROCEDURE Init
		lparameters tcDescription, ;
			tuListType, ;
			tnParentID, ;
			tlUseAbbreviation
		local lcFolder, ;
			lcLibrary, ;
			loLocalizer, ;
			llLocalize
		dodefault()
		
		* Save the passed parameters
		
		This.ListType  = tuListType
		This.ParentID  = evl(tnParentID, 0)
		
		* Set the min height and width.
		
		This.MinWidth  = This.Width
		This.MinHeight = This.Height
		
		* Localize the captions.
		
		lcFolder  = addbs(justpath(substr(sys(16), at(' ', sys(16), 2) + 1)))
		lcLibrary = fullpath('SFLocalize.vcx', lcFolder)
		do case
			case type('oLocalizer.Name') = 'C'
				loLocalizer = oLocalizer
				llLocalize  = .T.
			case file(lcLibrary)
				loLocalizer = newobject('SFLocalize', lcLibrary)
				loLocalizer.cResourceTable = fullpath('Resource.dbf', lcFolder)
				loLocalizer.cLanguage      = _vfp.oListManager.cLanguage
				llLocalize  = .T.
		endcase
		if llLocalize
			This.Caption           = strtran(loLocalizer.GetLocalizedString('FRM_CAP_EDITLIST'), ;
				'{0}', tcDescription)
			This.cmdAdd.Caption    = loLocalizer.GetLocalizedString('CMD_CAP_ADD')
			This.cmdRemove.Caption = loLocalizer.GetLocalizedString('CMD_CAP_REMOVE')
			This.grdValues.Column1.Header1.Caption = loLocalizer.GetLocalizedString('HDR_CAP_VALUE')
			This.grdValues.Column2.Header1.Caption = loLocalizer.GetLocalizedString('HDR_CAP_ABBREV')
		else
			This.Caption = 'Edit ' + tcDescription + ' List'
		endif llLocalize
		
		* Create a cursor of the desired type and use it in the grid.
		
		_vfp.oListManager.GetValuesForType('curValues', tuListType, tnParentID, .F., ;
			This.DataSessionId)
		index on upper(Value) tag Value
		This.grdValues.RecordSource = 'curValues'
		if tlUseAbbreviation
			This.grdValues.Column1.ControlSource = 'curValues.Value'
			This.grdValues.Column2.ControlSource = 'curValues.Abbrev'
		else
			This.grdValues.ColumnCount   = 1
			This.grdValues.Column1.Width = This.grdValues.Width
			This.grdValues.HeaderHeight  = 0
		endif tlUseAbbreviation
		
	ENDPROC

	PROCEDURE KeyPress
		* Close the form on Esc.
		
		lparameters tnKeyCode, ;
			tnShiftAltCtrl
		if tnKeyCode = 27
			This.Release()
		else
			dodefault(tnKeyCode, tnShiftAltCtrl)
		endif tnKeyCode = 27
		
	ENDPROC

	PROCEDURE cmdAdd.Click
		insert into curValues ;
				(Value) ;
			values ;
				('New Value')
		Thisform.grdValues.Refresh()
		Thisform.grdValues.SetFocus()
		
	ENDPROC

	PROCEDURE cmdRemove.Click
		delete in curValues
		Thisform.grdValues.Refresh()
		
	ENDPROC

	PROCEDURE cmdRemove.Refresh
		This.Enabled = reccount('curValues') > 0 and not deleted()
		
	ENDPROC

	PROCEDURE grdValues.Resize
		This.Column1.Width = This.Width
		
	ENDPROC

ENDDEFINE
